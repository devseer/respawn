// Generated by CoffeeScript 1.6.3
(function() {
  var Engine, Map, Mob, Player, Timers, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Engine = (function() {
    Engine.prototype.handle = {};

    function Engine(canvas, bgm, sfx) {
      this.handle = {
        canvas: canvas,
        bgm: bgm,
        sfx: sfx
      };
      this.map = new Map();
      this.player = new Player();
      this.timers = new Timers();
      this.mob = new Mob();
      this.main(this);
    }

    Engine.prototype.update = function() {
      this.player.update(this.map, this.timers);
      this.mob.update(this.map, this.timers);
      this.map.update();
      return this.timers.update();
    };

    Engine.prototype.draw = function(handle) {
      return this.map.draw(handle);
    };

    Engine.prototype.main = function(c) {
      var _this = this;
      c.update();
      c.draw(c.handle);
      return requestAnimationFrame(function() {
        return _this.main(c);
      });
    };

    return Engine;

  })();

  if (!root.Game) {
    root.Game = Engine;
  }

  Map = (function() {
    Map.prototype.list = [];

    function Map() {
      var i, j;
      this.height = 100;
      this.width = 100;
      this.viewport = {
        x: 0,
        y: 0,
        height: 9,
        width: 9
      };
      this.data = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (j = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(Math.random() > 0.8 && '#' || '.');
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
    }

    Map.prototype.update = function() {};

    Map.prototype.inBounds = function(x, y) {
      return x > 0 && y > 0 && x < this.data.length && y < this.data[0].length;
    };

    Map.prototype.canMove = function(x, y) {
      return this.inBounds(x, y) && this.data[x][y] === '.';
    };

    Map.prototype.updateViewport = function(x, y) {
      this.viewport.x = x - (this.viewport.width >> 1);
      return this.viewport.y = y - (this.viewport.height >> 1);
    };

    Map.prototype.inject = function(mobs) {
      return this.list = mobs;
    };

    Map.prototype.draw = function(handle) {
      var center, i, j, m, other, output, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      output = '';
      center = {
        x: this.viewport.x + (this.viewport.width >> 1),
        y: this.viewport.y + (this.viewport.height >> 1)
      };
      for (i = _i = _ref = this.viewport.y, _ref1 = this.viewport.y + this.viewport.height; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        for (j = _j = _ref2 = this.viewport.x, _ref3 = this.viewport.x + this.viewport.width; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
          if (this.inBounds(i, j)) {
            other = false;
            _ref4 = this.list;
            for (_k = 0, _len = _ref4.length; _k < _len; _k++) {
              m = _ref4[_k];
              if (m.pos.x === j && m.pos.y === i) {
                other = true;
                output += m.icon;
              }
            }
            if (!other) {
              output += ((j === center.x && i === center.y) && '@' || this.data[j][i]) + ' ';
            }
          } else {
            output += '  ';
          }
        }
        output += '\n';
      }
      return document.body.innerHTML = output;
    };

    return Map;

  })();

  Player = (function() {
    Player.prototype.canMove = true;

    Player.prototype.keys = [];

    Player.prototype.pos = {
      x: 20,
      y: 20
    };

    Player.prototype.action = {
      attack: 32,
      up: 87,
      down: 83,
      left: 65,
      right: 68
    };

    function Player(handle) {
      var i, k, _i;
      for (i = _i = 0; _i <= 255; i = ++_i) {
        this.keys.push(false);
      }
      k = this.keys;
      document.onkeydown = function(e) {
        return k[e.keyCode] = true;
      };
      document.onkeyup = function(e) {
        return k[e.keyCode] = false;
      };
    }

    Player.prototype.update = function(map, timers) {
      var last_x, last_y,
        _this = this;
      last_x = this.pos.x;
      last_y = this.pos.y;
      if (this.canMove) {
        if (this.keys[this.action.up] && map.canMove(this.pos.x, this.pos.y - 1)) {
          this.pos.y--;
        }
        if (this.keys[this.action.down] && map.canMove(this.pos.x, this.pos.y + 1)) {
          this.pos.y++;
        }
        if (this.keys[this.action.left] && map.canMove(this.pos.x - 1, this.pos.y)) {
          this.pos.x--;
        }
        if (this.keys[this.action.right] && map.canMove(this.pos.x + 1, this.pos.y)) {
          this.pos.x++;
        }
      }
      if (this.pos.x !== last_x || this.pos.y !== last_y) {
        this.canMove = false;
        timers.addTimer(200, function() {
          _this.canMove = true;
          return false;
        });
      }
      return map.updateViewport(this.pos.x, this.pos.y);
    };

    return Player;

  })();

  Timers = (function() {
    Timers.prototype.timestamp = 0;

    Timers.prototype.list = [];

    function Timers() {
      this.updateTime();
    }

    Timers.prototype.update = function() {
      var i, _results;
      this.updateTime();
      _results = [];
      for (i in this.list) {
        if (this.list[i].time < this.timestamp) {
          _results.push(this.executeTimer(this.list[i], i));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Timers.prototype.addTimer = function(interval, callback) {
      return this.list.push({
        interval: interval,
        time: this.timestamp + interval,
        callback: callback
      });
    };

    Timers.prototype.executeTimer = function(timer, index) {
      if (timer.callback()) {
        return this.renewTimer(timer);
      } else {
        return this.list.splice(index, 1);
      }
    };

    Timers.prototype.renewTimer = function(timer) {
      return timer.time = timer.interval + this.timestamp;
    };

    Timers.prototype.updateTime = function() {
      return this.timestamp = new Date().getTime();
    };

    return Timers;

  })();

  Mob = (function() {
    Mob.prototype.list = [];

    function Mob() {}

    Mob.prototype.update = function(map, timers) {
      while (this.list.length < 200) {
        this.list.push({
          icon: 'M',
          pos: {
            x: Math.floor(Math.random() * map.width - 1),
            y: Math.floor(Math.random() * map.height - 1)
          }
        });
      }
      return map.inject(this.list);
    };

    return Mob;

  })();

}).call(this);
